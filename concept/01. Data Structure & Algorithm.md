# 알고리즘 공부 이유
 - 효율적인 소스코드 작성을 위해
 - Time Complex  
   시간이 얼마나 걸리냐? 가 아니라,  
   알고리즘을 수행하는 step이 얼마나 많은가!  
 - Input이 많을 수록, 수행하는 시간이 얼마나 걸리는지!


# Array

특징
 - RAM (Random Access Memory, 휘발성 메모리)에 연속으로 공간을 할당
 - 데이터가 붙어서 들어가, 맨뒤에 데이터 삽입이 쉬움  
   데이터 읽기 쉬움
 - search(선형검색), 중간 Insert/delete 시간 걸림 
 - item이 많을 수록 bad case!


# 검색 알고리즘

1.선형 검색 알고리즘 (Linear Search)
 - 앞에서부터 순차적으로 비교하며 값을 검색 (One by one)
 - 최악의 경우, item이 맨 마지막에 있거나 없는 경우
 - 배열 사이즈가 클 수록 비 효율적  
   커지는 만큼 늘어남 (N step)
 
2.이진 검색 알고리즘 (Binary Search)
 - 이진검색은 모든 배열이 아닌, 정렬된 배열에서만 사용 가능 (트레이드 오프)  
   정렬된 배열에 삽입/삭제는 무작위 보다 시간이 걸림  
   비교 & 옮기기 과정이 필요
 - 이진? 반으로 쪼개다!
 - item 찾을 때 중간 index와 비교  
   작은 경우 왼쪽 index로, 큰 경우 오른쪽 index로 이동해서  
   다시 중간 index의 값과 비교 (반복)
 - 정렬된 item의 갯수가 2배로 증가해도, 비교하는 step은 1밖에 늘지 않음  
   (= 거대한 배열 다룰 때 효율적)
 - 검색 많이해야 하는 상황엔 sorting 하고 이진 탐색 이용하자 !!  


# Bog O

개념
 - 알고리즘의 스피드를 표현하는 방법
 - 시간의 빠르다, 느리다의 개념이 아님 (이건 하드웨어가 결정)
 - 💙알고리즘의 스피드는 완료까지 걸리는 절차(STEP)의 수  
 - 선형 검색 알고리즘의 경우, N개의 자료는 N개의 스텝이 필요  
   = O(N)

Big O를 배우는 이유?
 - 알고리즘 분석 빠르게 가능
 - 언제 무엇을 쓸지 빠르게 파악 가능
 - 코드 평가 가능 (미래에 어떻게 동작할지 파악 하니까!)

예시
 - 배열에서 특정 index(1번째 인덱스)의 값을 출력 하는 함수에서,  
   배열의 item 수가 몇만개로 늘어나도 동일한 수의 step만 필요함 (index로 가서 접근하기..)  
   이 경우 시간복잡도는 constant time(상수 시간)  
   N이 얼마나 크던, 끝나는데 동일한 step이 필요함 = O(1)
   
 - 그럼 맨 처음과 맨 끝 index의 값을 검색하는 함수의 경우?  
   O(2)가 아닌, 똑같이 O(1) !!  
   N이 무한대 늘어나도 step은 계속 2로 동일하니까!  
   --> Big O는 상수에 신경쓰지 않는다!

O(N)
 - N이 늘어날 수록, N만큼 step이 늘어나는 경우 = O(N)
 - for문을 돌려 N만큼 접근하는 경우 (N이 늘어나는 만큼 step 증가)

O(N^2)
 - Quadratic Time (2차 시간)
 - 2중 loops가 있을 때 발생 (중첩 반복)
 - N이 5개면, 25번 / N이 10개면 100번의 step이 필요
 
O(log N)
 - 로그 시간
 - 이진검색 알고리즘 (step을 절반으로 나누며 진행)
 - N이 두 배 증가해도, step은 1 증가
 - 참고 **  
   로그와 지수는 정 반대다 !  
   2^n = 32 // n은 5인것을 알 수 있음  
   n = log32 (생략 시 밑은 2) // n은 32를 2로 몇번을 나눠야 1이 나올지?  
   즉, n은 5 !!

단, 빅오가 전체를 반영하지 못하는 경우도 있다!

# 정렬(Sorting) 알고리즘
동일한 O(N) 시간복잡도를 가지지만, 전혀 다르게 동작함

Bubble Sort (버블정렬)
 - 자주 사용되지는 않음.. 좋은 알고리즘이 아니다!
 - 이해는 쉬움 ㅇ_ㅇ!
 - 2개의 item 선택하고, 비교하며 swap (반복)
 - 한 사이클 당, 배열의 N-1의 아이템 비교 필요  
   최악의 경우 모든 수를 swap  
   = O(N^2)

Selection Sort (선택정렬)
 - 0번(기준 index)부터 순차적으로 접근하여, 가작 작은 item의 index를 변수에 저장  
   해당 index (가장 작은 수)를 0번 index의 값과 swap
 - 다음 step에서 기준 index는 1  
   가장 작은 수 index 저장, 기준 index와 swap (반복)  
   (기준 index와 가장 작은 수 index가 동일하면 유지)  
   = O(N^2)
 - 버블정렬과 동일하게 N-1번의 비교는 하지만, 최악의 경우 N번의 swap은 하지 않음  
   매번 1번의 swap만 하면 된다 ~  
   버블보다 훨씬 낫다 !!! (2배 이상 빠를 수도 있음)
 - 하지만 시간복잡도는 같음!
 

Insertion Sort (삽입정렬)
 - 기준 index를 1로 잡음
   왼쪽에 기준 index 값 보다 큰 값이 있는지 확인  
   있다면 큰 값을 오른쪽으로 밀고, 자신은 왼쪽으로 이동
 - 다음 step  
   기준 index는 2  
   왼쪽 수 들과 비교하여, swap 반복
 - 삽입정렬은 필요한 아이템만 스캔하므로, 선택 정렬보다 빠름  
   (선택 정렬은 전체 모든 아이템 스캔)
 - 하지만 시간 복잡도는 같음! = O(N^2)

--> Big O가 모든 경우를 반영하지 못하는 예  
    이 경우, 최악의 시나리오가 아닌 평균 시나리오를 보자.  
    
선택/삽입 정렬은 DB가 작은 경우 GOOD!  
큰 경우.. Merge Sort와 Quick Sort 고려하자! 


# Hash Table
해시 테이블을 이용해, 어떻게 더 빠른 코드를 만들까!

Hash Table은 무엇인가
 - Key - value 시스템을 이용해 자료 정리 (ex. 단어사전)
 - 해시 테이블과 Array 비교 (예시)  
   ![화면 캡처 2022-01-23 115435](https://user-images.githubusercontent.com/98109708/150663036-7adb688b-c9c2-428a-81c8-50d848a615ff.png)  
   선형검색.. 오래 걸림!  
   = O(N)  
   이 경우, Hash Table은 이용하면 훨씬 효율적  
   ![화면 캡처 2022-01-23 115724](https://user-images.githubusercontent.com/98109708/150663104-b5cb1d1e-18df-4c61-a73f-bbae347b78e3.png)  
   해쉬 테이블에서 어떤 메뉴의 값을 찾아도, 1개의 스텝만 필요 (추가/삭제도!)  
   = O(1)

Hash Table 활용
 - key없이 value만 사용하기  
   ![화면 캡처 2022-01-23 120222](https://user-images.githubusercontent.com/98109708/150663212-62f26cf5-c098-4a21-a68b-cc6e81a6a6d5.png)  

Hash Table은 어떻게 작동하는가
 - 내부적으로 Array에 key-value를 저장  
   index를 알아야 O(1)로 접근 가능한데... 어떻게 더 빠를 수 있는거지..?!?!
 - 💙 Hash Function 때문!  
   해쉬 펑션은 내가 접근하고자 하는 key를 숫자(index)로 바꿔줌  
   즉, key에 대한 저장을 Hash Function은 찾기 쉽도록 index로 변환 후 사용  
   "beer"라는 키가 있으면, beer를 숫자로 변경하여 저장 위치를 잡음!  
   --> 따라서 Hash Table은 순서가 없는것! 
   
 - 만약, 저장 시 Hash Function이 뱉은 index가 겹친다면?  
   해시 충돌!!! (각기 다른 key에 대해, 해시함수가 동일한 숫자를 준 것)  

해시 충돌 대처 방법  
 1.겹치는 index 공간에 또 다른 배열을 넣는 것  
   - 두 개의 쌍을 저장
   - key를 찾아가서 해당 리스트에서 선형검색  
    --> 따라서 항상 O(1)인 것은 아님  
    충돌이 있을 경우 선형검색 사용하니까!
   
 2.index가 겹치면 옆 공간에 저장


# 상상속에만 존재하는 자료구조
일종의 "규칙"  
추상적 자료구조 ! (ADT)  
 - 자료구조의 방법이 코드로 정의된 것이 아님
 - 행동 양식만 정의 됨

Queue (큐)
 - 데이터가 수평 으로 되어 있음 (FIFO)
 - 먼저 들어간 데이터가, 가장 먼저 나옴
 - EX  
   Push 알림 기능  
   쇼핑 - 주문 처리

Stack (스택)
 - 데이터가 수직으로 쌓여 있음 (LIFO)
 - 마지막 들어간 데이터가, 가장 먼저 나옴
 - EX  
   브라우저의 뒤로가기  
   Ctrl + z (되돌리기)

